<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
  <meta name="google" content="notranslate">
  <title>Text2 - Camera</title>
<!-- Google tag (gtag.js) - GA4 -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ABCDEFG123"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-6J85STMJ14');
</script>
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #111;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      /* Enhanced full-height handling for browser UI */
      min-height: 100vh;
      min-height: 100dvh; /* Dynamic viewport height */
      min-height: 100svh; /* Small viewport height - most reliable */
      height: 100vh;
      height: 100dvh;
      height: 100svh;
      overflow: hidden;
      overscroll-behavior: none;
      /* Enhanced safe areas with better fallbacks */
      padding-top: max(env(safe-area-inset-top, 0px), 10px);
      padding-bottom: max(env(safe-area-inset-bottom, 0px), 10px);
      padding-left: env(safe-area-inset-left, 0px);
      padding-right: env(safe-area-inset-right, 0px);
      /* Prevent zoom on double tap */
      touch-action: manipulation;
      /* Ensure content is always visible */
      position: relative;
    }
    
    /* Adaptive container that responds to viewport changes */
    .app-container {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
      max-height: 100vh;
      max-height: 100dvh;
      max-height: 100svh;
      /* Ensure container respects safe areas */
      padding-left: env(safe-area-inset-left, 0px);
      padding-right: env(safe-area-inset-right, 0px);
    }
    
    #camera {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
      width: 100%;
      position: relative;
      min-height: 0; /* Allow flex shrinking */
      /* Ensure camera doesn't get too small with better viewport units */
      min-height: clamp(200px, 40svh, 400px);
      /* Ensure camera area is always accessible */
      max-height: calc(100svh - 120px); /* Reserve space for toolbar */
    }
    video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #captureBtn {
      position: absolute;
      bottom: max(clamp(10px, 2svh, 20px), 15px); /* Ensure minimum distance from bottom */
      left: 50%;
      transform: translateX(-50%);
      width: clamp(50px, 8svh, 80px);
      height: clamp(50px, 8svh, 80px);
      border-radius: 50%;
      border: clamp(2px, 0.5svh, 5px) solid #fff;
      background: #ff3b30;
      box-shadow: 0 0 15px rgba(255, 59, 48, 0.8);
      z-index: 10;
      transition: all 0.3s ease;
      /* Ensure button is always accessible */
      min-width: 50px;
      min-height: 50px;
    }
    #captureBtn.recording {
      background: #ff3b30;
      animation: pulse 1.5s infinite;
    }
    #captureBtn.video-mode {
      border-radius: 20%;
      background: #ff3b30;
    }
    #captureBtn.video-mode.recording {
      background: #ff3b30;
      border-radius: 20%;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 15px rgba(255, 59, 48, 0.8); }
      50% { box-shadow: 0 0 25px rgba(255, 59, 48, 1); }
      100% { box-shadow: 0 0 15px rgba(255, 59, 48, 0.8); }
    }
    #recordingTimer {
      position: absolute;
      top: max(clamp(10px, 2svh, 20px), 15px); /* Ensure minimum distance from top */
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: #ff3b30;
      padding: 8px 16px;
      border-radius: 20px;
      font-family: monospace;
      font-size: clamp(14px, 2svh, 18px);
      font-weight: bold;
      z-index: 10;
      display: none;
      /* Ensure timer is always visible */
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #toolbar {
      display: flex;
      justify-content: space-around;
      align-items: center;
      background: #222;
      padding: clamp(4px, 1svh, 8px);
      width: 100%;
      flex-shrink: 0; /* Don't shrink toolbar */
      min-height: clamp(40px, 6svh, 60px);
      /* Ensure toolbar is always accessible */
      position: relative;
      z-index: 5;
      /* Add safe area padding */
      padding-left: max(clamp(4px, 1svh, 8px), env(safe-area-inset-left, 0px));
      padding-right: max(clamp(4px, 1svh, 8px), env(safe-area-inset-right, 0px));
      padding-bottom: max(clamp(4px, 1svh, 8px), env(safe-area-inset-bottom, 0px));
    }
    .tool-btn {
      background: none;
      border: none;
      color: #fff;
      font-size: clamp(14px, 2svh, 20px);
      cursor: pointer;
      padding: clamp(4px, 0.8svh, 8px);
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      /* Ensure buttons are always tappable */
      min-width: 44px;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    /* Modal base */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 16px;
    }
    .modal.show { display: flex; }
    .modal-content {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 12px;
      width: min(100%, 920px);
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border-bottom: 1px solid #333;
      background: #111;
    }
    .modal-title { font-weight: bold; }
    .close-btn {
      background: none;
      border: none;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
    }
    .modal-body { padding: 12px; overflow: auto; }
    /* Library grid */
    .lib-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 10px;
    }
    .lib-item { position: relative; }
    .lib-thumb {
      width: 100%;
      aspect-ratio: 1/1;
      object-fit: cover;
      border-radius: 10px;
      border: 1px solid #333;
      display: block;
      cursor: pointer;
    }
    .lib-actions {
      position: absolute;
      right: 6px;
      bottom: 6px;
      display: flex;
      gap: 6px;
    }
    .btn {
      background: #2a2a2a;
      border: 1px solid #444;
      color: #fff;
      border-radius: 8px;
      padding: 8px 10px;
      cursor: pointer;
      font-size: 14px;
    }
    .btn.primary { background: #0a84ff; border-color: #0a84ff; }
    .btn.danger { background: #ff453a; border-color: #ff453a; }
    /* Preview modal */
    .preview-image {
      max-width: 90vw;
      max-height: 70dvh;
      width: auto;
      height: auto;
      object-fit: contain;
      border-radius: 10px;
      border: 1px solid #333;
      display: block;
      margin: 0 auto;
      background: #000;
    }
    .preview-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
      padding-top: 12px;
    }

    /* Enhanced responsive breakpoints */
    @media (max-height: 600px) {
      #camera { 
        min-height: clamp(150px, 35svh, 300px);
        max-height: calc(100svh - 100px); /* More space for toolbar */
      }
      #toolbar { 
        min-height: clamp(35px, 5svh, 50px);
        padding: clamp(3px, 0.8svh, 6px);
      }
      #captureBtn {
        width: clamp(45px, 7svh, 70px);
        height: clamp(45px, 7svh, 70px);
        bottom: max(clamp(8px, 1.5svh, 15px), 12px);
      }
      .tool-btn {
        font-size: clamp(12px, 1.8svh, 18px);
        padding: clamp(3px, 0.6svh, 6px);
      }
    }
    
    @media (max-height: 500px) {
      #camera { 
        min-height: clamp(120px, 30svh, 250px);
        max-height: calc(100svh - 80px); /* Reserve more space for toolbar */
      }
      #toolbar { 
        min-height: clamp(30px, 4svh, 45px);
        padding: clamp(2px, 0.5svh, 6px);
      }
      #captureBtn {
        width: clamp(40px, 6svh, 60px);
        height: clamp(40px, 6svh, 60px);
        bottom: max(clamp(8px, 1.5svh, 15px), 10px);
      }
      .tool-btn { 
        font-size: clamp(12px, 1.8svh, 18px);
        padding: clamp(3px, 0.6svh, 6px);
        min-width: 40px;
        min-height: 40px;
      }
    }
    
    @media (max-height: 400px) {
      #camera { 
        min-height: clamp(100px, 25svh, 200px);
        max-height: calc(100svh - 60px); /* Minimal space for toolbar */
      }
      #toolbar { 
        min-height: clamp(25px, 3svh, 40px);
        padding: clamp(1px, 0.3svh, 4px);
      }
      #captureBtn {
        width: clamp(35px, 5svh, 55px);
        height: clamp(35px, 5svh, 55px);
        bottom: max(clamp(5px, 1svh, 10px), 8px);
      }
      .tool-btn { 
        font-size: clamp(10px, 1.5svh, 16px);
        padding: clamp(2px, 0.4svh, 5px);
        min-width: 36px;
        min-height: 36px;
      }
      .mini-btn {
        font-size: clamp(8px, 1.5svh, 10px);
        padding: clamp(1px, 0.2svh, 3px) clamp(3px, 0.5svh, 5px);
        min-width: 32px;
        min-height: 32px;
      }
    }

    /* Responsive tweaks for landscape / small heights */
    @media (orientation: landscape) and (max-height: 520px) {
      body { 
        padding-top: max(env(safe-area-inset-top, 0px), 5px);
        padding-bottom: max(env(safe-area-inset-bottom, 0px), 5px);
      }
      #camera { 
        min-height: clamp(120px, 30svh, 300px);
        max-height: calc(100svh - 70px);
      }
      #toolbar { 
        padding: clamp(3px, 0.6svh, 8px);
        min-height: clamp(30px, 4svh, 50px);
      }
      .tool-btn { 
        font-size: clamp(14px, 2svh, 18px);
        min-width: 42px;
        min-height: 42px;
      }
      #captureBtn {
        width: clamp(40px, 6svh, 65px);
        height: clamp(40px, 6svh, 65px);
        bottom: max(clamp(8px, 1.5svh, 15px), 12px);
      }
    }
    
    /* Ultra-compact mode for very constrained spaces */
    @media (orientation: landscape) and (max-height: 400px) {
      #camera { 
        min-height: clamp(80px, 25svh, 200px);
        max-height: calc(100svh - 50px);
      }
      #toolbar { 
        padding: clamp(2px, 0.4svh, 6px);
        min-height: clamp(25px, 3svh, 40px);
      }
      .tool-btn { 
        font-size: clamp(12px, 1.8svh, 16px);
        padding: clamp(2px, 0.4svh, 6px);
        min-width: 38px;
        min-height: 38px;
      }
      #captureBtn {
        width: clamp(35px, 5svh, 55px);
        height: clamp(35px, 5svh, 55px);
        bottom: max(clamp(5px, 1svh, 10px), 8px);
      }
    }
    /* iOS-style button */
    .ios-btn {
      padding: 12px 24px;
      border-radius: 9999px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(42, 42, 42, 0.8);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      font-size: 16px;
      font-weight: 500;
      color: #ffffff;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .ios-btn:hover {
      background: rgba(60, 60, 60, 0.9);
      border-color: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }
    .ios-btn:active { 
      background: rgba(30, 30, 30, 0.9);
      transform: translateY(0px);
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.4);
    }
    /* Size variants aligned to existing UI */
    .tool-btn.ios-btn { 
      padding: 8px 14px; 
      font-size: clamp(14px, 2.2vw, 16px);
      background: rgba(34, 34, 34, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.15);
    }
    .mini-btn.ios-btn { 
      padding: 4px 8px; 
      font-size: 12px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .btn.ios-btn { 
      padding: 10px 16px; 
      font-size: 14px;
      background: rgba(42, 42, 42, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .btn.primary.ios-btn { 
      color: #ffffff; 
      background: rgba(10, 132, 255, 0.8);
      border: 1px solid rgba(10, 132, 255, 0.6);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .btn.primary.ios-btn:hover {
      background: rgba(10, 132, 255, 0.9);
      border-color: rgba(10, 132, 255, 0.8);
    }
    .btn.danger.ios-btn { 
      color: #ffffff; 
      background: rgba(255, 69, 58, 0.8);
      border: 1px solid rgba(255, 69, 58, 0.6);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .btn.danger.ios-btn:hover {
      background: rgba(255, 69, 58, 0.9);
      border-color: rgba(255, 69, 58, 0.8);
    }
    /* Settings menu */
    #settingsMenu {
      position: fixed;
      right: 10px;
      top: calc(52px + env(safe-area-inset-top, 0px));
      background: rgba(26,26,26,0.95);
      border: 1px solid #333;
      border-radius: 10px;
      padding: 8px;
      display: none;
      z-index: 1200;
      box-shadow: 0 6px 24px rgba(0,0,0,0.4);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #settingsMenu.show { display: block; }
    #settingsMenu .menu-item { margin: 4px 0; }
    
    /* Additional mobile optimizations */
    @supports (height: 100svh) {
      body {
        height: 100svh;
        min-height: 100svh;
      }
      .app-container {
        height: 100svh;
        max-height: 100svh;
      }
    }
    
    /* Fallback for older browsers */
    @supports not (height: 100svh) {
      body {
        height: 100vh;
        min-height: 100vh;
      }
      .app-container {
        height: 100vh;
        max-height: 100vh;
      }
    }
    
    /* Prevent iOS Safari bounce */
    body {
      -webkit-overflow-scrolling: touch;
      position: fixed;
      width: 100%;
      height: 100%;
    }
    
    /* Ensure touch targets are accessible */
    @media (pointer: coarse) {
      .tool-btn, #captureBtn {
        min-width: 44px;
        min-height: 44px;
      }
    }
  </style>
  <script src="https://code.iconify.design/iconify-icon/2.1.0/iconify-icon.min.js"></script>
</head>
<body>
  <div id="camera">
    <video id="video" autoplay playsinline muted></video>
    <button id="captureBtn"></button>
    <div id="recordingTimer">00:00</div>
  </div>

  <div id="toolbar">
    <button class="tool-btn ios-btn" id="switchCam" aria-label="Switch camera"><iconify-icon icon="ion:camera-reverse-outline"></iconify-icon></button>
    <button class="tool-btn ios-btn" id="modeToggle" aria-label="Switch mode" title="Switch between photo and video"><iconify-icon icon="ion:camera-outline"></iconify-icon><span id="modeText">Photo</span></button>
    <button class="tool-btn ios-btn" id="settings" aria-label="Settings"><iconify-icon icon="ion:settings-outline"></iconify-icon></button>
    <button class="tool-btn ios-btn" id="autoSaveToggle" title="Auto download photos" aria-pressed="false"></button>
    <button class="tool-btn ios-btn" id="openLibrary" title="View library" aria-label="Library"><iconify-icon icon="ion:images-outline"></iconify-icon></button>
  </div>

  <!-- Settings Menu -->
  <div id="settingsMenu" role="menu" aria-hidden="true">
    <button id="btnReloadAssets" class="btn ios-btn menu-item"><iconify-icon icon="ion:refresh-outline"></iconify-icon><span>Update</span></button>
  </div>

  <!-- Library Modal -->
  <div id="libraryModal" class="modal" aria-hidden="true">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Photo Library</div>
        <div style="display: flex; gap: 8px; align-items: center;">
          <button id="downloadAllBtn" class="btn primary ios-btn" title="Download all photos" style="padding: 6px 12px; font-size: 14px;">
            <iconify-icon icon="ion:download-outline"></iconify-icon><span>Download All</span>
          </button>
          <button class="close-btn ios-btn" data-close-lib aria-label="Close"><iconify-icon icon="ion:close-outline"></iconify-icon></button>
        </div>
      </div>
      <div class="modal-body">
        <div id="libraryGrid" class="lib-grid"></div>
      </div>
    </div>
  </div>

  <!-- Preview Modal -->
  <div id="previewModal" class="modal" aria-hidden="true">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">View Photo</div>
        <button class="close-btn ios-btn" data-close-preview aria-label="Close"><iconify-icon icon="ion:close-outline"></iconify-icon></button>
      </div>
      <div class="modal-body">
        <img id="previewImage" class="preview-image" alt="Preview" />
        <div class="preview-actions">
          <button id="downloadPreview" class="btn primary ios-btn"><iconify-icon icon="ion:download-outline"></iconify-icon><span>Download</span></button>
          <button id="deletePreview" class="btn danger ios-btn"><iconify-icon icon="ion:trash-outline"></iconify-icon><span>Delete</span></button>
        </div>
      </div>
    </div>
  </div>

  <canvas id="canvas" style="display:none;"></canvas>

  <script>
    // Enhanced viewport height handling for mobile browsers
    function setAppVhUnit() {
      const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
      const svh = window.innerHeight; // Small viewport height
      const dvh = window.innerHeight; // Dynamic viewport height
      
      document.documentElement.style.setProperty('--app-vh', `${vh * 0.01}px`);
      document.documentElement.style.setProperty('--app-svh', `${svh * 0.01}px`);
      document.documentElement.style.setProperty('--app-dvh', `${dvh * 0.01}px`);
      
      // Update body padding to ensure content is always visible
      const safeTop = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-area-inset-top') || '0');
      const safeBottom = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-area-inset-bottom') || '0');
      
      document.body.style.paddingTop = `${Math.max(safeTop, 10)}px`;
      document.body.style.paddingBottom = `${Math.max(safeBottom, 10)}px`;
    }
    
    setAppVhUnit();
    window.addEventListener('resize', setAppVhUnit, { passive: true });
    window.addEventListener('orientationchange', setAppVhUnit, { passive: true });
    
    // Handle visual viewport changes (keyboard, browser UI)
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', setAppVhUnit, { passive: true });
    }

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const captureBtn = document.getElementById('captureBtn');
    const openLibraryBtn = document.getElementById('openLibrary');
    const autoSaveToggle = document.getElementById('autoSaveToggle');
    const settingsBtn = document.getElementById('settings');
    const settingsMenu = document.getElementById('settingsMenu');
    const btnReloadAssets = document.getElementById('btnReloadAssets');
    const libraryModal = document.getElementById('libraryModal');
    const libraryGrid = document.getElementById('libraryGrid');
    const previewModal = document.getElementById('previewModal');
    const previewImage = document.getElementById('previewImage');
    const downloadPreviewBtn = document.getElementById('downloadPreview');
    const deletePreviewBtn = document.getElementById('deletePreview');
    const modeToggle = document.getElementById('modeToggle');
    const modeText = document.getElementById('modeText');
    const recordingTimer = document.getElementById('recordingTimer');
    let currentStream;
    let useFront = true;
    let photos = [];
    let videos = [];
    let activePhotoId = null;
    let activeVideoId = null;
    let autoSave = true;
    let currentMode = 'photo'; // 'photo' or 'video'
    let mediaRecorder = null;
    let recordedChunks = [];
    let recordingStartTime = null;
    let recordingInterval = null;

    // ===== IndexedDB persistence =====
    const DB_NAME = 'camera-db';
    const DB_VERSION = 2;
    const STORE_PHOTOS = 'photos';
    const STORE_VIDEOS = 'videos';

    function openDb() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(STORE_PHOTOS)) {
            const store = db.createObjectStore(STORE_PHOTOS, { keyPath: 'id' });
            store.createIndex('createdAt', 'createdAt');
          }
          if (!db.objectStoreNames.contains(STORE_VIDEOS)) {
            const store = db.createObjectStore(STORE_VIDEOS, { keyPath: 'id' });
            store.createIndex('createdAt', 'createdAt');
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function dbSavePhoto(photo) {
      try {
        const db = await openDb();
        await new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_PHOTOS, 'readwrite');
          tx.objectStore(STORE_PHOTOS).put(photo);
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      } catch (e) {
        console.error('Error saving photo to cache', e);
      }
    }

    async function dbDeletePhoto(id) {
      try {
        const db = await openDb();
        await new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_PHOTOS, 'readwrite');
          tx.objectStore(STORE_PHOTOS).delete(id);
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      } catch (e) {
        console.error('Error deleting photo from cache', e);
      }
    }

    async function dbLoadAllPhotos() {
      try {
        const db = await openDb();
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_PHOTOS, 'readonly');
          const req = tx.objectStore(STORE_PHOTOS).getAll();
          req.onsuccess = () => {
            const list = req.result || [];
            // Sort newest first
            list.sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
            resolve(list);
          };
          req.onerror = () => reject(req.error);
        });
      } catch (e) {
        console.error('Error loading photos from cache', e);
        return [];
      }
    }

    async function dbSaveVideo(video) {
      try {
        const db = await openDb();
        await new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_VIDEOS, 'readwrite');
          tx.objectStore(STORE_VIDEOS).put(video);
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      } catch (e) {
        console.error('Error saving video to cache', e);
      }
    }

    async function dbDeleteVideo(id) {
      try {
        const db = await openDb();
        await new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_VIDEOS, 'readwrite');
          tx.objectStore(STORE_VIDEOS).delete(id);
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      } catch (e) {
        console.error('Error deleting video from cache', e);
      }
    }

    async function dbLoadAllVideos() {
      try {
        const db = await openDb();
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_VIDEOS, 'readonly');
          const req = tx.objectStore(STORE_VIDEOS).getAll();
          req.onsuccess = () => {
            const list = req.result || [];
            // Sort newest first
            list.sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
            resolve(list);
          };
          req.onerror = () => reject(req.error);
        });
      } catch (e) {
        console.error('Error loading videos from cache', e);
        return [];
      }
    }

    async function initCamera() {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }
      const preferredConstraints = {
        video: {
          facingMode: useFront ? 'user' : 'environment',
          width: { ideal: 1920 },
          height: { ideal: 1080 },
          aspectRatio: { ideal: window.innerWidth / Math.max(1, window.innerHeight) },
        },
        audio: false,
      };
      const fallbackConstraints = {
        video: { facingMode: useFront ? 'user' : 'environment' },
        audio: false,
      };
      try {
        currentStream = await navigator.mediaDevices.getUserMedia(preferredConstraints);
      } catch (e1) {
        try {
          currentStream = await navigator.mediaDevices.getUserMedia(fallbackConstraints);
        } catch (e2) {
          console.error('Cannot access camera', e2);
          alert('Cannot access camera. Please check access permissions or try a different browser.');
          return;
        }
      }
      video.muted = true;
      video.playsInline = true;
      video.srcObject = currentStream;
      // Mirror preview for front camera by default
      video.style.transform = useFront ? 'scaleX(-1)' : 'none';
    }

    captureBtn.onclick = () => {
      if (currentMode === 'photo') {
        capturePhoto();
      } else {
        toggleVideoRecording();
      }
    };

    function capturePhoto() {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext('2d');
      // Mirror captured image to match preview when using front camera
      ctx.save();
      if (useFront) {
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
      }
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      ctx.restore();
      const dataUrl = canvas.toDataURL('image/png');
      const photo = addPhoto(dataUrl);
      if (autoSave && photo) {
        downloadPhoto(photo.id);
      }
    }

    function toggleVideoRecording() {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        stopVideoRecording();
      } else {
        startVideoRecording();
      }
    }

    function startVideoRecording() {
      if (!currentStream) return;
      
      recordedChunks = [];
      mediaRecorder = new MediaRecorder(currentStream, {
        mimeType: 'video/webm;codecs=vp9'
      });
      
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          recordedChunks.push(event.data);
        }
      };
      
      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const video = addVideo(blob);
        if (autoSave && video) {
          downloadVideo(video.id);
        }
      };
      
      mediaRecorder.start();
      recordingStartTime = Date.now();
      recordingInterval = setInterval(updateRecordingTimer, 1000);
      
      // Update UI
      captureBtn.classList.add('recording');
      recordingTimer.style.display = 'block';
      updateRecordingTimer();
    }

    function stopVideoRecording() {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
      }
      
      // Update UI
      captureBtn.classList.remove('recording');
      recordingTimer.style.display = 'none';
      if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
      }
    }

    function updateRecordingTimer() {
      if (recordingStartTime) {
        const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        recordingTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
    }

    // Reinitialize camera on orientation change for better aspect match
    window.addEventListener('orientationchange', () => {
      setTimeout(() => initCamera(), 300);
    }, { passive: true });

    function addPhoto(dataUrl) {
      const id = 'p_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8);
      const index = photos.length + 1;
      const filename = `photo_${index}.png`;
      const createdAt = Date.now();
      const photo = { id, dataUrl, filename, createdAt };
      photos.unshift(photo);
      renderThumbRow();
      if (libraryModal.classList.contains('show')) renderLibrary();
      // Save to IndexedDB for offline cache
      dbSavePhoto(photo);
      return photo;
    }

    function addVideo(blob) {
      const id = 'v_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8);
      const index = videos.length + 1;
      const filename = `video_${index}.webm`;
      const createdAt = Date.now();
      const videoUrl = URL.createObjectURL(blob);
      const video = { id, blob, videoUrl, filename, createdAt };
      videos.unshift(video);
      renderThumbRow();
      if (libraryModal.classList.contains('show')) renderLibrary();
      // Save to IndexedDB for offline cache
      dbSaveVideo(video);
      return video;
    }

    function renderThumbRow() {
      // This function is no longer needed as gallery is removed.
      // The photo display is now handled by the preview modal.
    }

    function openLibrary() {
      renderLibrary();
      libraryModal.classList.add('show');
      libraryModal.setAttribute('aria-hidden', 'false');
    }

    function closeLibrary() {
      libraryModal.classList.remove('show');
      libraryModal.setAttribute('aria-hidden', 'true');
    }

    function renderLibrary() {
      libraryGrid.innerHTML = '';
      
      // Combine photos and videos, sort by creation date
      const allMedia = [
        ...photos.map(p => ({ ...p, type: 'photo' })),
        ...videos.map(v => ({ ...v, type: 'video' }))
      ].sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));

      allMedia.forEach((media) => {
        const item = document.createElement('div');
        item.className = 'lib-item';
        item.dataset.id = media.id;
        item.dataset.type = media.type;

        let thumb;
        if (media.type === 'photo') {
          thumb = document.createElement('img');
          thumb.src = media.dataUrl;
          thumb.className = 'lib-thumb';
          thumb.alt = media.filename;
        } else {
          thumb = document.createElement('video');
          thumb.src = media.videoUrl;
          thumb.className = 'lib-thumb';
          thumb.alt = media.filename;
          thumb.muted = true;
          thumb.preload = 'metadata';
        }
        
        thumb.addEventListener('click', () => openPreview(media.id, media.type));

        const actions = document.createElement('div');
        actions.className = 'lib-actions';

        const dl = document.createElement('button');
        dl.className = 'mini-btn ios-btn';
        dl.innerHTML = '<iconify-icon icon="ion:download-outline"></iconify-icon>';
        dl.addEventListener('click', (e) => {
          e.stopPropagation();
          if (media.type === 'photo') {
            downloadPhoto(media.id);
          } else {
            downloadVideo(media.id);
          }
        });

        const del = document.createElement('button');
        del.className = 'mini-btn ios-btn';
        del.innerHTML = '<iconify-icon icon="ion:trash-outline"></iconify-icon>';
        del.addEventListener('click', (e) => {
          e.stopPropagation();
          if (media.type === 'photo') {
            deletePhoto(media.id);
          } else {
            deleteVideo(media.id);
          }
        });

        actions.appendChild(dl);
        actions.appendChild(del);
        item.appendChild(thumb);
        item.appendChild(actions);
        libraryGrid.appendChild(item);
      });
    }

    function openPreview(mediaId, mediaType) {
      let media;
      if (mediaType === 'photo') {
        media = photos.find(x => x.id === mediaId);
        activePhotoId = mediaId;
        activeVideoId = null;
      } else {
        media = videos.find(x => x.id === mediaId);
        activeVideoId = mediaId;
        activePhotoId = null;
      }
      
      if (!media) return;
      
      // Update modal title
      const modalTitle = document.querySelector('#previewModal .modal-title');
      modalTitle.textContent = mediaType === 'photo' ? 'View Photo' : 'View Video';
      
      // Update preview content
      if (mediaType === 'photo') {
        previewImage.src = media.dataUrl;
        previewImage.alt = media.filename;
        previewImage.style.display = 'block';
        // Hide video element if it exists
        const previewVideo = document.getElementById('previewVideo');
        if (previewVideo) {
          previewVideo.style.display = 'none';
        }
      } else {
        // Create video element if it doesn't exist
        let previewVideo = document.getElementById('previewVideo');
        if (!previewVideo) {
          previewVideo = document.createElement('video');
          previewVideo.id = 'previewVideo';
          previewVideo.className = 'preview-image';
          previewVideo.controls = true;
          previewImage.parentNode.insertBefore(previewVideo, previewImage);
        }
        previewVideo.src = media.videoUrl;
        previewVideo.style.display = 'block';
        previewImage.style.display = 'none';
      }
      
      previewModal.classList.add('show');
      previewModal.setAttribute('aria-hidden', 'false');
    }

    function closePreview() {
      previewModal.classList.remove('show');
      previewModal.setAttribute('aria-hidden', 'true');
      activePhotoId = null;
      activeVideoId = null;
    }

    function downloadPhoto(photoId) {
      const photo = photos.find(x => x.id === photoId);
      if (!photo) return;
      const a = document.createElement('a');
      a.href = photo.dataUrl;
      a.download = photo.filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    function downloadVideo(videoId) {
      const video = videos.find(x => x.id === videoId);
      if (!video) return;
      const a = document.createElement('a');
      a.href = video.videoUrl;
      a.download = video.filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    function deletePhoto(photoId) {
      const i = photos.findIndex(x => x.id === photoId);
      if (i === -1) return;
      photos.splice(i, 1);
      renderThumbRow();
      if (libraryModal.classList.contains('show')) renderLibrary();
      if (activePhotoId === photoId) closePreview();
      // Delete from IndexedDB
      dbDeletePhoto(photoId);
    }

    function deleteVideo(videoId) {
      const i = videos.findIndex(x => x.id === videoId);
      if (i === -1) return;
      const video = videos[i];
      URL.revokeObjectURL(video.videoUrl);
      videos.splice(i, 1);
      renderThumbRow();
      if (libraryModal.classList.contains('show')) renderLibrary();
      if (activeVideoId === videoId) closePreview();
      // Delete from IndexedDB
      dbDeleteVideo(videoId);
    }

    document.getElementById('switchCam').onclick = () => {
      useFront = !useFront;
      initCamera();
    };

    // Mode toggle functionality
    function toggleMode() {
      currentMode = currentMode === 'photo' ? 'video' : 'photo';
      updateModeUI();
    }

    function updateModeUI() {
      const icon = modeToggle.querySelector('iconify-icon');
      if (currentMode === 'photo') {
        modeText.textContent = 'Photo';
        icon.setAttribute('icon', 'ion:camera-outline');
        captureBtn.classList.remove('video-mode');
      } else {
        modeText.textContent = 'Video';
        icon.setAttribute('icon', 'ion:videocam-outline');
        captureBtn.classList.add('video-mode');
      }
    }

    modeToggle.addEventListener('click', toggleMode);

    // Auto save toggle
    function updateAutoSaveBtn() {
      const label = autoSave ? 'ON' : 'OFF';
      autoSaveToggle.innerHTML = '<iconify-icon icon="ion:save-outline"></iconify-icon><span>'+label+'</span>';
      autoSaveToggle.setAttribute('aria-pressed', String(autoSave));
    }
    autoSaveToggle.addEventListener('click', () => {
      autoSave = !autoSave;
      updateAutoSaveBtn();
    });
    updateAutoSaveBtn();

    // Toolbar: open library
    openLibraryBtn.addEventListener('click', openLibrary);

    // Close buttons and backdrop click
    libraryModal.addEventListener('click', (e) => {
      if (e.target === libraryModal || e.target.hasAttribute('data-close-lib')) closeLibrary();
    });
    previewModal.addEventListener('click', (e) => {
      if (e.target === previewModal || e.target.hasAttribute('data-close-preview')) closePreview();
    });

    // Preview actions
    downloadPreviewBtn.addEventListener('click', () => {
      if (activePhotoId) downloadPhoto(activePhotoId);
      if (activeVideoId) downloadVideo(activeVideoId);
    });
    deletePreviewBtn.addEventListener('click', () => {
      if (activePhotoId) deletePhoto(activePhotoId);
      if (activeVideoId) deleteVideo(activeVideoId);
    });

    // Download All functionality
    document.getElementById('downloadAllBtn').addEventListener('click', () => {
      const totalMedia = photos.length + videos.length;
      if (totalMedia === 0) {
        alert('Không có ảnh hoặc video nào để tải xuống.');
        return;
      }
      
      // Create a confirmation dialog
      if (!confirm(`Bạn có muốn tải xuống tất cả ${totalMedia} file (${photos.length} ảnh, ${videos.length} video) không?`)) {
        return;
      }
      
      let downloadCount = 0;
      
      // Download each photo with a small delay to avoid overwhelming the browser
      photos.forEach((photo, index) => {
        setTimeout(() => {
          const a = document.createElement('a');
          a.href = photo.dataUrl;
          a.download = photo.filename;
          document.body.appendChild(a);
          a.click();
          a.remove();
          downloadCount++;
        }, downloadCount * 100); // 100ms delay between each download
      });
      
      // Download each video with a small delay
      videos.forEach((video, index) => {
        setTimeout(() => {
          const a = document.createElement('a');
          a.href = video.videoUrl;
          a.download = video.filename;
          document.body.appendChild(a);
          a.click();
          a.remove();
          downloadCount++;
        }, downloadCount * 100);
      });
      
      // Show success message
      setTimeout(() => {
        alert(`Đã bắt đầu tải xuống ${totalMedia} file.`);
      }, 200);
    });

    // Initialize: load photos and videos from cache then start camera
    (async () => {
      const cachedPhotos = await dbLoadAllPhotos();
      const cachedVideos = await dbLoadAllVideos();
      
      if (Array.isArray(cachedPhotos) && cachedPhotos.length) {
        photos = cachedPhotos;
      }
      
      if (Array.isArray(cachedVideos) && cachedVideos.length) {
        videos = cachedVideos;
      }
      
      if (photos.length > 0 || videos.length > 0) {
        renderThumbRow();
      }
      
      initCamera();
      updateModeUI(); // Initialize UI state
    })();

    // ===== Service Worker Registration =====
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js').then((reg) => {
          // Listen for updatefound to auto-activate new SW
          if (reg.waiting) {
            reg.waiting.postMessage({ type: 'SKIP_WAITING' });
          }
          reg.addEventListener('updatefound', () => {
            const nw = reg.installing;
            if (!nw) return;
            nw.addEventListener('statechange', () => {
              if (nw.state === 'installed' && navigator.serviceWorker.controller) {
                // New version installed; optionally notify user
              }
            });
          });
        }).catch(() => {});
      });
      navigator.serviceWorker.addEventListener('message', (event) => {
        if (event.data && event.data.type === 'RELOAD_NOW') {
          window.location.reload(true);
        }
      });
    }

    // ===== Settings menu actions =====
    function toggleSettingsMenu(show) {
      const willShow = typeof show === 'boolean' ? show : !settingsMenu.classList.contains('show');
      if (willShow) {
        settingsMenu.classList.add('show');
        settingsMenu.setAttribute('aria-hidden', 'false');
      } else {
        settingsMenu.classList.remove('show');
        settingsMenu.setAttribute('aria-hidden', 'true');
      }
    }
    settingsBtn.addEventListener('click', () => toggleSettingsMenu());
    document.addEventListener('click', (e) => {
      const within = settingsMenu.contains(e.target) || settingsBtn.contains(e.target);
      if (!within) toggleSettingsMenu(false);
    }, { passive: true });

    btnReloadAssets.addEventListener('click', async () => {
      try {
        const reg = await navigator.serviceWorker.getRegistration();
        if (reg && reg.active) {
          reg.active.postMessage({ type: 'CLEAR_AND_RELOAD' });
          // Give SW a moment to clear caches, then hard reload
          setTimeout(() => window.location.reload(true), 300);
        } else {
          // Fallback: clear caches via CacheStorage API then reload
          if ('caches' in window) {
            const keys = await caches.keys();
            await Promise.all(keys.map(k => caches.delete(k)));
          }
          window.location.reload(true);
        }
      } catch (e) {
        window.location.reload(true);
      }
    });
  </script>
</body>
</html>
