<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Optimize viewport for all devices, prevent zoom -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
  <meta name="google" content="notranslate">
  
  <!-- SEO Meta Tags -->
  <title>Text2 Camera</title>
  <meta name="description" content="Online photo and video capture app with webcam. Modern interface, easy to use, supports high-quality photos and HD video recording.">
  <meta name="keywords" content="online photo capture, online video recording, webcam, camera app">
  <meta name="author" content="Text2">
  <meta name="robots" content="index, follow">
  <meta name="language" content="English">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://camera.text2.click/">
  <meta property="og:title" content="Text2 Camera - Online Photo & Video Capture App">
  <meta property="og:description" content="Online photo and video capture app with webcam. Modern interface, easy to use.">
  <meta property="og:site_name" content="Text2">
  <meta property="og:locale" content="en_US">
  
  <!-- Twitter -->
  <meta property="twitter:card" content="summary">
  <meta property="twitter:url" content="https://camera.text2.click/">
  <meta property="twitter:title" content="Text2 Camera - Online Photo & Video Capture App">
  <meta property="twitter:description" content="Online photo and video capture app with webcam. Modern interface, easy to use.">
  
  <!-- Additional SEO Meta Tags -->
  <meta name="theme-color" content="#000000">
  <meta name="application-name" content="Text2 Camera">
  <meta name="apple-mobile-web-app-title" content="Text2 Camera">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  
  <!-- Alternate Languages -->
  <link rel="alternate" hreflang="en" href="https://camera.text2.click/">
  <link rel="alternate" hreflang="x-default" href="https://camera.text2.click/">

  <!-- Google tag (gtag.js) - GA4 (Using boss's code) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-6J85STMJ14"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-6J85STMJ14');
  </script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1722731267767270"
crossorigin="anonymous"></script> 
  <!-- Favicons (Using boss's paths) -->
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  
  <!-- Preconnect for Performance -->
  <link rel="preconnect" href="https://cdn.tailwindcss.com">
  <link rel="preconnect" href="https://code.iconify.design">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  
  <!-- DNS Prefetch -->
  <link rel="dns-prefetch" href="//www.googletagmanager.com">
  <link rel="dns-prefetch" href="//pagead2.googlesyndication.com">
  
  <!-- Load Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Load Iconify Icons -->
  <script src="https://code.iconify.design/iconify-icon/2.1.0/iconify-icon.min.js"></script>
  
  <!-- Load Inter font (modern UI standard) -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Structured Data - WebApplication -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Text2 Camera",
    "description": "Free online photo and video capture app with high quality",
    "url": "https://camera.text2.click/",
    "applicationCategory": "MultimediaApplication",
    "operatingSystem": "Web Browser",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "author": {
      "@type": "Organization",
      "name": "Text2"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Text2"
    },
    "inLanguage": "en",
    "browserRequirements": "Requires JavaScript. Requires HTML5.",
    "softwareVersion": "1.0",
    "featureList": [
      "High-quality photo capture",
      "HD video recording",
      "Local storage",
      "Responsive interface",
      "Front/rear camera support",
      "Automatic download"
    ]
  }
  </script>

  <!-- Structured Data - Organization -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "name": "Text2",
    "url": "https://camera.text2.click/",
    "logo": "https://camera.text2.click/favicon-32x32.png",
    "sameAs": []
  }
  </script>
  
  <style>
    /* Custom CSS tweaks */
    body {
      font-family: 'Inter', sans-serif;
      /* Prevent page scrolling, double-tap zoom */
      overscroll-behavior: none;
      touch-action: manipulation;
      /* Ensure full height on mobile, even when browser bars hide/show */
      height: 100vh; /* Fallback */
      height: 100svh;
      overflow: hidden;
      position: fixed;
      width: 100%;
    }
    
    /* Ensure video preview is always 1:1 or 4:3 etc. depending on stream */
    #video {
      /* Keep video fitted and covering the frame */
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    /* Safe area (for notches, navigation bars) */
    .safe-top {
      padding-top: env(safe-area-inset-top);
    }
    .safe-bottom {
      padding-bottom: env(safe-area-inset-bottom);
    }
    .safe-left {
      padding-left: env(safe-area-inset-left);
    }
    .safe-right {
      padding-right: env(safe-area-inset-right);
    }
  </style>
</head>
<body class="bg-black text-white antialiased">

  <!-- Main App Container -->
  <div class="flex flex-col h-full h-svh w-full">
    
    <!-- Camera View -->
    <div id="camera" class="flex-1 relative bg-black overflow-hidden">
      <video id="video" autoplay playsinline muted></video>
      
      <!-- Recording Timer -->
      <div id="recordingTimer" class="hidden absolute left-1/2 -translate-x-1/2 bg-black/60 backdrop-blur-sm text-red-500 font-mono font-bold px-4 py-2 rounded-full text-lg top-[calc(1rem+env(safe-area-inset-top))]">
        00:00
      </div>
      
      <!-- Capture Button Wrapper -->
      <div class="absolute bottom-0 left-0 right-0 flex justify-center pb-[calc(1.5rem+env(safe-area-inset-bottom))]">
        <button id="captureBtn" aria-label="Capture" class="w-16 h-16 rounded-full bg-white shadow-lg border-4 border-white transition-all duration-300 ease-in-out transform active:scale-95"></button>
      </div>
    </div>

    <!-- Toolbar -->
    <div id="toolbar" class="bg-black/80 backdrop-blur-sm safe-bottom safe-left safe-right">
      <div class="flex justify-between items-center px-4 pt-4 pb-[calc(1rem+env(safe-area-inset-bottom))]">
        
        <!-- Tool Buttons -->
        <button class="tool-btn" id="switchCam" aria-label="Switch camera">
          <iconify-icon icon="ion:camera-reverse-outline" class="text-3xl"></iconify-icon>
        </button>
        
        <button class="tool-btn flex items-center gap-2 bg-zinc-800 px-4 py-2 rounded-full" id="modeToggle" aria-label="Switch mode" title="Switch between photo and video">
          <iconify-icon icon="ion:camera-outline" class="text-xl"></iconify-icon>
          <span id="modeText" class="text-sm font-medium">Photo</span>
        </button>
        
        <button class="tool-btn" id="settings" aria-label="Settings">
          <iconify-icon icon="ion:settings-outline" class="text-3xl"></iconify-icon>
        </button>
        
        <button class="tool-btn" id="autoSaveToggle" title="Auto download photos" aria-pressed="false">
          <!-- Content will be updated by JS -->
        </button>
        
        <button class="tool-btn" id="openLibrary" title="View library" aria-label="Library">
          <iconify-icon icon="ion:images-outline" class="text-3xl"></iconify-icon>
        </button>
      </div>
    </div>
  </div>

  <!-- Settings Menu (Dropdown) -->
  <div id="settingsMenu" class="hidden fixed z-[100] bg-zinc-800/90 backdrop-blur-lg border border-zinc-700 rounded-lg shadow-xl p-2 top-[calc(4rem+env(safe-area-inset-top))] right-4 safe-right" role="menu" aria-hidden="true">
    <button id="btnReloadAssets" class="menu-item flex items-center gap-2 w-full text-left px-3 py-2 rounded-md text-sm text-white hover:bg-zinc-700">
      <iconify-icon icon="ion:refresh-outline" class="text-lg"></iconify-icon>
      <span>Update App</span>
    </button>
  </div>

  <!-- Library Modal -->
  <div id="libraryModal" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm p-4 safe-top safe-bottom safe-left safe-right" aria-hidden="true">
    <div class="modal-content bg-zinc-900 text-zinc-100 rounded-2xl shadow-xl w-full max-w-3xl max-h-[85svh] flex flex-col">
      <!-- Header -->
      <div class="modal-header flex justify-between items-center p-4 border-b border-zinc-700 flex-shrink-0">
        <h2 class="modal-title text-lg font-semibold">Photo Library</h2>
        <div class="flex gap-2">
          <button id="downloadAllBtn" class="btn primary flex items-center gap-2 text-sm">
            <iconify-icon icon="ion:download-outline" class="text-lg"></iconify-icon>
            <span>Download All</span>
          </button>
          <button class="close-btn" data-close-lib aria-label="Close">
            <iconify-icon icon="ion:close-outline" class="text-2xl"></iconify-icon>
          </button>
        </div>
      </div>
      <!-- Body -->
      <div class="modal-body p-4 overflow-y-auto">
        <div id="libraryGrid" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-2">
          <!-- Library will be rendered here -->
        </div>
      </div>
    </div>
  </div>

  <!-- Preview Modal -->
  <div id="previewModal" class="hidden fixed inset-0 z-[60] flex items-center justify-center bg-black/70 backdrop-blur-sm p-4 safe-top safe-bottom safe-left safe-right" aria-hidden="true">
    <div class="modal-content bg-zinc-900 text-zinc-100 rounded-2xl shadow-xl w-full max-w-3xl max-h-[85svh] flex flex-col">
      <!-- Header -->
      <div class="modal-header flex justify-between items-center p-4 border-b border-zinc-700 flex-shrink-0">
        <h2 id="previewTitle" class="modal-title text-lg font-semibold">View Media</h2>
        <button class="close-btn" data-close-preview aria-label="Close">
          <iconify-icon icon="ion:close-outline" class="text-2xl"></iconify-icon>
        </button>
      </div>
      <!-- Body -->
      <div class="modal-body p-4 overflow-y-auto flex flex-col items-center gap-4">
        <!-- Image/video container -->
        <div class="relative w-full max-h-[60svh] flex justify-center items-center">
          <img id="previewImage" class="preview-media hidden max-w-full max-h-[60svh] object-contain rounded-lg" alt="Preview" />
          <video id="previewVideo" class="preview-media hidden max-w-full max-h-[60svh] object-contain rounded-lg" controls></video>
        </div>
        <!-- Actions -->
        <div class="preview-actions flex gap-4 justify-center">
          <button id="downloadPreview" class="btn primary flex items-center gap-2">
            <iconify-icon icon="ion:download-outline" class="text-lg"></iconify-icon>
            <span>Download</span>
          </button>
          <button id="deletePreview" class="btn danger flex items-center gap-2">
            <iconify-icon icon="ion:trash-outline" class="text-lg"></iconify-icon>
            <span>Delete</span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Custom Confirm/Alert Modal (Replace alert/confirm) -->
  <div id="confirmModal" class="hidden fixed inset-0 z-[100] flex items-center justify-center bg-black/70 backdrop-blur-sm p-4" aria-hidden="true">
    <div class="modal-content bg-zinc-800 text-zinc-100 rounded-2xl shadow-xl w-full max-w-sm">
      <!-- Header -->
      <div class="modal-header p-5 text-center">
        <h2 id="confirmTitle" class="modal-title text-lg font-semibold">Confirmation</h2>
      </div>
      <!-- Body -->
      <div class="modal-body px-5 pb-5">
        <p id="confirmMessage" class="text-sm text-zinc-300 text-center">Are you sure?</p>
      </div>
      <!-- Footer -->
      <div class="modal-footer flex border-t border-zinc-700">
        <button id="confirmCancel" class="w-1/2 p-3 text-blue-500 font-medium hover:bg-zinc-700/50 rounded-bl-2xl transition-colors">
          Cancel
        </button>
        <button id="confirmOk" class="w-1/2 p-3 text-blue-500 font-bold hover:bg-zinc-700/50 rounded-br-2xl border-l border-zinc-700 transition-colors">
          OK
        </button>
      </div>
    </div>
  </div>


  <!-- Hidden canvas for image processing -->
  <canvas id="canvas" style="display:none;"></canvas>

  <!-- CSS for elements styled by JS -->
  <style>
    /* Styling for common UI buttons */
    .tool-btn {
      @apply text-zinc-300 hover:text-white transition-colors duration-200 p-2 rounded-full active:scale-90;
    }
    .btn {
      @apply px-4 py-2 rounded-full font-semibold text-sm transition-all duration-200 transform active:scale-95 shadow-lg border;
    }
    .btn.primary {
      @apply bg-blue-600 text-white border-blue-600 hover:bg-blue-500;
    }
    .btn.danger {
      @apply bg-red-600 text-white border-red-600 hover:bg-red-500;
    }
    .close-btn {
      @apply text-zinc-400 hover:text-white hover:bg-zinc-700 rounded-full p-1 transition-all;
    }
    /* Style for AutoSave button */
    #autoSaveToggle {
      @apply text-xs px-3 py-2 rounded-full flex items-center gap-1.5 font-medium;
    }
    #autoSaveToggle[aria-pressed="true"] {
      @apply bg-blue-600 text-white;
    }
    #autoSaveToggle[aria-pressed="false"] {
      @apply bg-zinc-800 text-zinc-300 hover:bg-zinc-700;
    }
  </style>

  <script>
    'use strict';
    
    // ===== Element Refs =====
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const captureBtn = document.getElementById('captureBtn');
    const openLibraryBtn = document.getElementById('openLibrary');
    const autoSaveToggle = document.getElementById('autoSaveToggle');
    const settingsBtn = document.getElementById('settings');
    const settingsMenu = document.getElementById('settingsMenu');
    const btnReloadAssets = document.getElementById('btnReloadAssets');
    const modeToggle = document.getElementById('modeToggle');
    const modeText = document.getElementById('modeText');
    const recordingTimer = document.getElementById('recordingTimer');

    // Library Modal
    const libraryModal = document.getElementById('libraryModal');
    const libraryGrid = document.getElementById('libraryGrid');
    const downloadAllBtn = document.getElementById('downloadAllBtn');

    // Preview Modal
    const previewModal = document.getElementById('previewModal');
    const previewTitle = document.getElementById('previewTitle');
    const previewImage = document.getElementById('previewImage');
    const previewVideo = document.getElementById('previewVideo');
    const downloadPreviewBtn = document.getElementById('downloadPreview');
    const deletePreviewBtn = document.getElementById('deletePreview');

    // Confirm Modal
    const confirmModal = document.getElementById('confirmModal');
    const confirmTitle = document.getElementById('confirmTitle');
    const confirmMessage = document.getElementById('confirmMessage');
    const confirmOkBtn = document.getElementById('confirmOk');
    const confirmCancelBtn = document.getElementById('confirmCancel');

    // ===== App State =====
    let currentStream;
    let useFront = true;
    let photos = [];
    let videos = [];
    let activeMediaId = null;
    let activeMediaType = null;
    let autoSave = true;
    let currentMode = 'photo'; // 'photo' or 'video'
    let mediaRecorder = null;
    let recordedChunks = [];
    let recordingStartTime = null;
    let recordingInterval = null;
    let confirmCallback = null;

    // ===== IndexedDB persistence =====
    const DB_NAME = 'camera-db';
    const DB_VERSION = 2;
    const STORE_PHOTOS = 'photos';
    const STORE_VIDEOS = 'videos';

    function openDb() {
      return new Promise((resolve, reject) => {
        try {
          const req = indexedDB.open(DB_NAME, DB_VERSION);
          req.onupgradeneeded = () => {
            const db = req.result;
            if (!db.objectStoreNames.contains(STORE_PHOTOS)) {
              db.createObjectStore(STORE_PHOTOS, { keyPath: 'id' }).createIndex('createdAt', 'createdAt');
            }
            if (!db.objectStoreNames.contains(STORE_VIDEOS)) {
              db.createObjectStore(STORE_VIDEOS, { keyPath: 'id' }).createIndex('createdAt', 'createdAt');
            }
          };
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        } catch (e) {
          reject(e);
        }
      });
    }

    async function dbSave(storeName, data) {
      try {
        const db = await openDb();
        await new Promise((resolve, reject) => {
          const tx = db.transaction(storeName, 'readwrite');
          tx.objectStore(storeName).put(data);
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      } catch (e) {
        console.error(`Error saving to ${storeName}`, e);
      }
    }

    async function dbDelete(storeName, id) {
      try {
        const db = await openDb();
        await new Promise((resolve, reject) => {
          const tx = db.transaction(storeName, 'readwrite');
          tx.objectStore(storeName).delete(id);
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      } catch (e) {
        console.error(`Error deleting from ${storeName}`, e);
      }
    }

    async function dbLoadAll(storeName) {
      try {
        const db = await openDb();
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(storeName, 'readonly');
          const req = tx.objectStore(storeName).getAll();
          req.onsuccess = () => {
            const list = req.result || [];
            list.sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
            resolve(list);
          };
          req.onerror = () => reject(req.error);
        });
      } catch (e) {
        console.error(`Error loading from ${storeName}`, e);
        return [];
      }
    }

    // ===== Custom Alert / Confirm Functions =====
    function showAlert(title, message) {
      confirmTitle.textContent = title;
      confirmMessage.textContent = message;
      confirmCallback = null;
      confirmOkBtn.textContent = 'OK';
      confirmCancelBtn.classList.add('hidden');
      confirmModal.classList.remove('hidden');
    }

    function showConfirm(title, message, onOk) {
      confirmTitle.textContent = title;
      confirmMessage.textContent = message;
      confirmCallback = onOk;
      confirmOkBtn.textContent = 'OK';
      confirmCancelBtn.classList.remove('hidden');
      confirmModal.classList.remove('hidden');
    }

    confirmOkBtn.addEventListener('click', () => {
      if (confirmCallback) {
        confirmCallback();
      }
      confirmModal.classList.add('hidden');
    });

    confirmCancelBtn.addEventListener('click', () => {
      confirmCallback = null;
      confirmModal.classList.add('hidden');
    });
    
    // ===== Camera Logic =====
    async function initCamera() {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }
      
      const constraints = {
        video: {
          facingMode: useFront ? 'user' : 'environment',
          width: { ideal: 1920 },
          height: { ideal: 1080 },
        },
        audio: true, // Enable audio for video recording
      };

      try {
        currentStream = await navigator.mediaDevices.getUserMedia(constraints);
      } catch (e) {
        console.error('Cannot access camera', e);
        try {
          // Try again with video only if audio fails
          constraints.audio = false;
          currentStream = await navigator.mediaDevices.getUserMedia(constraints);
        } catch (e2) {
          console.error('Cannot access camera (fallback)', e2);
          showAlert('Camera Error', 'Cannot access camera. Please check permissions or try a different browser.');
          return;
        }
      }
      
      video.srcObject = currentStream;
      video.style.transform = useFront ? 'scaleX(-1)' : 'none';
    }

    function capturePhoto() {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext('2d');
      
      // Flip image if using front camera
      ctx.save();
      if (useFront) {
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
      }
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      ctx.restore();
      
      const dataUrl = canvas.toDataURL('image/png');
      const photo = addPhoto(dataUrl);
      if (autoSave && photo) {
        downloadMedia(photo.id, 'photo');
      }
    }

    function startVideoRecording() {
      if (!currentStream) return;
      
      recordedChunks = [];
      // Try common mimeTypes
      const mimeTypes = [
        'video/webm;codecs=vp9,opus',
        'video/webm;codecs=vp8,opus',
        'video/webm',
        'video/mp4'
      ];
      const supportedMimeType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type));
      
      if (!supportedMimeType) {
        showAlert('Video Recording Error', 'No supported video format found on this browser.');
        return;
      }

      mediaRecorder = new MediaRecorder(currentStream, { mimeType: supportedMimeType });
      
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) recordedChunks.push(event.data);
      };
      
      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: supportedMimeType });
        const video = addVideo(blob, supportedMimeType);
        if (autoSave && video) {
          downloadMedia(video.id, 'video');
        }
      };
      
      mediaRecorder.start();
      recordingStartTime = Date.now();
      recordingInterval = setInterval(updateRecordingTimer, 1000);
      
      // Update UI
      captureBtn.classList.remove('bg-white', 'rounded-full');
      captureBtn.classList.add('bg-red-500', 'rounded-xl', 'animate-pulse');
      recordingTimer.classList.remove('hidden');
      updateRecordingTimer();
    }

    function stopVideoRecording() {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
      }
      
      // Update UI
      captureBtn.classList.add('bg-white', 'rounded-full');
      captureBtn.classList.remove('bg-red-500', 'rounded-xl', 'animate-pulse');
      recordingTimer.classList.add('hidden');
      if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
      }
    }

    function updateRecordingTimer() {
      if (recordingStartTime) {
        const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        recordingTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
    }

    function toggleVideoRecording() {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        stopVideoRecording();
      } else {
        startVideoRecording();
      }
    }

    // ===== Media Management =====
    function addPhoto(dataUrl) {
      const id = 'p_' + Date.now();
      const filename = `photo_${id}.png`;
      const createdAt = Date.now();
      const photo = { id, dataUrl, filename, createdAt, type: 'photo' };
      photos.unshift(photo);
      dbSave(STORE_PHOTOS, photo);
      if (libraryModal.classList.contains('hidden') === false) renderLibrary();
      return photo;
    }

    function addVideo(blob, mimeType) {
      const id = 'v_' + Date.now();
      const extension = mimeType.split('/')[1].split(';')[0];
      const filename = `video_${id}.${extension}`;
      const createdAt = Date.now();
      const videoUrl = URL.createObjectURL(blob);
      const video = { id, blob, videoUrl, filename, createdAt, type: 'video' };
      videos.unshift(video);
      dbSave(STORE_VIDEOS, { id, blob, filename, createdAt, type: 'video' }); // Only save blob to DB
      if (libraryModal.classList.contains('hidden') === false) renderLibrary();
      return video;
    }

    function deleteMedia(mediaId, mediaType) {
      if (mediaType === 'photo') {
        const i = photos.findIndex(x => x.id === mediaId);
        if (i > -1) photos.splice(i, 1);
        dbDelete(STORE_PHOTOS, mediaId);
      } else {
        const i = videos.findIndex(x => x.id === mediaId);
        if (i > -1) {
          URL.revokeObjectURL(videos[i].videoUrl);
          videos.splice(i, 1);
        }
        dbDelete(STORE_VIDEOS, mediaId);
      }
      
      renderLibrary();
      if (activeMediaId === mediaId) closePreview();
    }
    
    function downloadMedia(mediaId, mediaType) {
      const media = (mediaType === 'photo' ? photos : videos).find(x => x.id === mediaId);
      if (!media) return;
      
      const a = document.createElement('a');
      a.href = media.type === 'photo' ? media.dataUrl : media.videoUrl;
      a.download = media.filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    // ===== UI Functions =====
    function openLibrary() {
      renderLibrary();
      libraryModal.classList.remove('hidden');
      libraryModal.setAttribute('aria-hidden', 'false');
    }

    function closeLibrary() {
      libraryModal.classList.add('hidden');
      libraryModal.setAttribute('aria-hidden', 'true');
    }

    function renderLibrary() {
      libraryGrid.innerHTML = '';
      
      const allMedia = [
        ...photos,
        ...videos.map(v => ({...v, videoUrl: URL.createObjectURL(v.blob)})) // Create new URL when rendering
      ].sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));

      if (allMedia.length === 0) {
        libraryGrid.innerHTML = `<p class="col-span-full text-center text-zinc-400">Your library is empty. Take some photos or videos!</p>`;
        return;
      }

      allMedia.forEach((media) => {
        const item = document.createElement('div');
        item.className = 'relative aspect-square rounded-lg overflow-hidden border border-zinc-700 group cursor-pointer';
        item.dataset.id = media.id;
        item.dataset.type = media.type;

        let thumb;
        if (media.type === 'photo') {
          thumb = document.createElement('img');
          thumb.src = media.dataUrl;
          thumb.className = 'w-full h-full object-cover';
          thumb.alt = media.filename;
        } else {
          thumb = document.createElement('video');
          thumb.src = media.videoUrl;
          thumb.className = 'w-full h-full object-cover';
          thumb.alt = media.filename;
          thumb.muted = true;
          thumb.preload = 'metadata';
        }
        
        item.addEventListener('click', () => openPreview(media.id, media.type));

        const actions = document.createElement('div');
        actions.className = 'absolute bottom-1 right-1 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity';

        const dl = document.createElement('button');
        dl.className = 'p-1.5 bg-black/60 backdrop-blur-sm rounded-full text-white hover:bg-black/80';
        dl.innerHTML = '<iconify-icon icon="ion:download-outline" class="text-sm block"></iconify-icon>';
        dl.addEventListener('click', (e) => {
          e.stopPropagation();
          downloadMedia(media.id, media.type);
        });

        const del = document.createElement('button');
        del.className = 'p-1.5 bg-black/60 backdrop-blur-sm rounded-full text-red-500 hover:bg-black/80';
        del.innerHTML = '<iconify-icon icon="ion:trash-outline" class="text-sm block"></iconify-icon>';
        del.addEventListener('click', (e) => {
          e.stopPropagation();
          showConfirm('Delete Media?', `Are you sure you want to delete this ${media.type}?`, () => {
            deleteMedia(media.id, media.type);
          });
        });

        actions.appendChild(dl);
        actions.appendChild(del);
        item.appendChild(thumb);
        if (media.type === 'video') {
          const videoIcon = document.createElement('div');
          videoIcon.className = 'absolute top-1 left-1 bg-black/60 backdrop-blur-sm rounded-full p-1';
          videoIcon.innerHTML = '<iconify-icon icon="ion:videocam-outline" class="text-xs text-white block"></iconify-icon>';
          item.appendChild(videoIcon);
        }
        item.appendChild(actions);
        libraryGrid.appendChild(item);
      });
    }

    function openPreview(mediaId, mediaType) {
      const media = (mediaType === 'photo' ? photos : videos).find(x => x.id === mediaId);
      if (!media) return;

      activeMediaId = mediaId;
      activeMediaType = mediaType;
      
      previewTitle.textContent = mediaType === 'photo' ? 'View Photo' : 'View Video';
      
      if (mediaType === 'photo') {
        previewImage.src = media.dataUrl;
        previewImage.alt = media.filename;
        previewImage.classList.remove('hidden');
        previewVideo.classList.add('hidden');
        previewVideo.pause();
        previewVideo.src = '';
      } else {
        previewVideo.src = media.videoUrl;
        previewVideo.classList.remove('hidden');
        previewImage.classList.add('hidden');
        previewImage.src = '';
      }
      
      previewModal.classList.remove('hidden');
      previewModal.setAttribute('aria-hidden', 'false');
    }

    function closePreview() {
      previewModal.classList.add('hidden');
      previewModal.setAttribute('aria-hidden', 'true');
      activeMediaId = null;
      activeMediaType = null;
      // Stop video when closing
      previewVideo.pause();
      previewVideo.src = '';
      previewImage.src = '';
    }

    function toggleMode() {
      // Stop video recording if currently recording
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        stopVideoRecording();
      }
      currentMode = currentMode === 'photo' ? 'video' : 'photo';
      updateModeUI();
    }

    function updateModeUI() {
      const icon = modeToggle.querySelector('iconify-icon');
      if (currentMode === 'photo') {
        modeText.textContent = 'Photo';
        icon.setAttribute('icon', 'ion:camera-outline');
        captureBtn.classList.remove('rounded-xl'); // Switch to round
        captureBtn.classList.add('rounded-full', 'bg-white');
      } else {
        modeText.textContent = 'Video';
        icon.setAttribute('icon', 'ion:videocam-outline');
        captureBtn.classList.remove('rounded-full'); // Switch to square
        captureBtn.classList.add('rounded-xl', 'bg-white');
      }
    }

    function updateAutoSaveBtn() {
      const label = autoSave ? 'ON' : 'OFF';
      autoSaveToggle.innerHTML = `<iconify-icon icon="ion:save-outline" class="text-lg"></iconify-icon><span>${label}</span>`;
      autoSaveToggle.setAttribute('aria-pressed', String(autoSave));
    }

    function toggleSettingsMenu(show) {
      const willShow = typeof show === 'boolean' ? show : settingsMenu.classList.contains('hidden');
      if (willShow) {
        settingsMenu.classList.remove('hidden');
        settingsMenu.setAttribute('aria-hidden', 'false');
      } else {
        settingsMenu.classList.add('hidden');
        settingsMenu.setAttribute('aria-hidden', 'true');
      }
    }
    
    // ===== Event Listeners =====
    captureBtn.addEventListener('click', () => {
      if (currentMode === 'photo') {
        capturePhoto();
      } else {
        toggleVideoRecording();
      }
    });

    document.getElementById('switchCam').addEventListener('click', () => {
      useFront = !useFront;
      initCamera();
    });

    modeToggle.addEventListener('click', toggleMode);

    autoSaveToggle.addEventListener('click', () => {
      autoSave = !autoSave;
      updateAutoSaveBtn();
    });

    openLibraryBtn.addEventListener('click', openLibrary);
    
    // Close modals
    libraryModal.addEventListener('click', (e) => {
      if (e.target === libraryModal || e.target.closest('[data-close-lib]')) closeLibrary();
    });
    previewModal.addEventListener('click', (e) => {
      if (e.target === previewModal || e.target.closest('[data-close-preview]')) closePreview();
    });

    // Preview actions
    downloadPreviewBtn.addEventListener('click', () => {
      if (activeMediaId) downloadMedia(activeMediaId, activeMediaType);
    });
    deletePreviewBtn.addEventListener('click', () => {
      if (activeMediaId) {
        showConfirm(`Delete ${activeMediaType}?`, `Are you sure you want to delete this ${activeMediaType}?`, () => {
          deleteMedia(activeMediaId, activeMediaType);
        });
      }
    });

    // Download All
    downloadAllBtn.addEventListener('click', () => {
      const totalMedia = photos.length + videos.length;
      if (totalMedia === 0) {
        showAlert('Library Empty', 'There are no photos or videos to download.');
        return;
      }
      
      showConfirm(
        'Download All?',
        `Do you want to download all ${totalMedia} files (${photos.length} photos, ${videos.length} videos)?`,
        () => {
          let downloadCount = 0;
          [...photos, ...videos].forEach((media) => {
            setTimeout(() => {
              downloadMedia(media.id, media.type);
            }, downloadCount * 100);
            downloadCount++;
          });
          setTimeout(() => {
            showAlert('Download Started', `Started downloading ${totalMedia} files.`);
          }, 200);
        }
      );
    });
    
    // Settings Menu
    settingsBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleSettingsMenu();
    });
    document.addEventListener('click', (e) => {
      if (!settingsMenu.contains(e.target) && !settingsBtn.contains(e.target)) {
        toggleSettingsMenu(false);
      }
    }, { passive: true });

    btnReloadAssets.addEventListener('click', async () => {
      try {
        const reg = await navigator.serviceWorker.getRegistration();
        if (reg && reg.active) {
          reg.active.postMessage({ type: 'CLEAR_AND_RELOAD' });
          setTimeout(() => window.location.reload(true), 300);
        } else {
          if ('caches' in window) {
            const keys = await caches.keys();
            await Promise.all(keys.map(k => caches.delete(k)));
          }
          window.location.reload(true);
        }
      } catch (e) {
        window.location.reload(true);
      }
    });

    // ===== Service Worker =====
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js').then((reg) => {
          if (reg.waiting) {
            reg.waiting.postMessage({ type: 'SKIP_WAITING' });
          }
          reg.addEventListener('updatefound', () => {
            const nw = reg.installing;
            if (!nw) return;
            nw.addEventListener('statechange', () => {
              if (nw.state === 'installed' && navigator.serviceWorker.controller) {
                // New version installed
              }
            });
          });
        }).catch(() => {});
      });
      navigator.serviceWorker.addEventListener('message', (event) => {
        if (event.data && event.data.type === 'RELOAD_NOW') {
          window.location.reload(true);
        }
      });
    }

    // ===== App Initialization =====
    (async () => {
      const cachedPhotos = await dbLoadAll(STORE_PHOTOS);
      if (Array.isArray(cachedPhotos) && cachedPhotos.length) {
        photos = cachedPhotos;
      }
      
      const cachedVideosBlobs = await dbLoadAll(STORE_VIDEOS);
      if (Array.isArray(cachedVideosBlobs) && cachedVideosBlobs.length) {
        // Recreate videoUrl from blob
        videos = cachedVideosBlobs.map(v => ({
          ...v,
          videoUrl: URL.createObjectURL(v.blob)
        }));
      }
      
      await initCamera();
      updateModeUI();
      updateAutoSaveBtn();
    })();
    
  </script>
</body>
</html>
